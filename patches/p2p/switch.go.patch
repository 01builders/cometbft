diff --git a/p2p/switch.go b/p2p/switch.go
index 60d26729b..8bdaa9617 100644
--- a/p2p/switch.go
+++ b/p2p/switch.go
@@ -12,6 +12,8 @@ import (
 	"github.com/tendermint/tendermint/libs/rand"
 	"github.com/tendermint/tendermint/libs/service"
 	"github.com/tendermint/tendermint/p2p/conn"
+	"github.com/tendermint/tendermint/pkg/trace"
+	"github.com/tendermint/tendermint/pkg/trace/schema"
 )
 
 const (
@@ -91,8 +93,9 @@ type Switch struct {
 
 	rng *rand.Rand // seed for randomizing dial times and orders
 
-	metrics *Metrics
-	mlc     *metricsLabelCache
+	metrics     *Metrics
+	mlc         *metricsLabelCache
+	traceClient trace.Tracer
 }
 
 // NetAddress returns the address the switch is listening on.
@@ -126,6 +129,7 @@ func NewSwitch(
 		persistentPeersAddrs: make([]*NetAddress, 0),
 		unconditionalPeerIDs: make(map[ID]struct{}),
 		mlc:                  newMetricsLabelCache(),
+		traceClient:          trace.NoOpTracer(),
 	}
 
 	// Ensure we have a completely undeterministic PRNG.
@@ -155,6 +159,10 @@ func WithMetrics(metrics *Metrics) SwitchOption {
 	return func(sw *Switch) { sw.metrics = metrics }
 }
 
+func WithTracer(tracer trace.Tracer) SwitchOption {
+	return func(sw *Switch) { sw.traceClient = tracer }
+}
+
 //---------------------------------------------------------------------
 // Switch setup
 
@@ -373,20 +381,37 @@ func (sw *Switch) StopPeerForError(peer Peer, reason interface{}) {
 	sw.stopAndRemovePeer(peer, reason)
 
 	if peer.IsPersistent() {
-		var addr *NetAddress
-		if peer.IsOutbound() { // socket address for outbound peers
-			addr = peer.SocketAddr()
-		} else { // self-reported address for inbound peers
-			var err error
-			addr, err = peer.NodeInfo().NetAddress()
-			if err != nil {
-				sw.Logger.Error("Wanted to reconnect to inbound peer, but self-reported address is wrong",
-					"peer", peer, "err", err)
-				return
-			}
+		addr, err := sw.getPeerAddress(peer)
+		if err != nil {
+			sw.Logger.Error("Failed to get address for persistent peer", "peer", peer, "err", err)
+			return
 		}
 		go sw.reconnectToPeer(addr)
 	}
+
+	if peer.HasIPChanged() {
+		addr, err := sw.getPeerAddress(peer)
+		if err != nil {
+			sw.Logger.Error("Failed to get address for peer with changed IP", "peer", peer, "err", err)
+		}
+		go sw.reconnectToPeer(addr)
+	}
+}
+
+// getPeerAddress returns the appropriate NetAddress for a given peer,
+// handling both outbound and inbound peers.
+func (sw *Switch) getPeerAddress(peer Peer) (*NetAddress, error) {
+	if peer.IsOutbound() {
+		return peer.SocketAddr(), nil
+	}
+	// For inbound peers, get the self-reported address
+	addr, err := peer.NodeInfo().NetAddress()
+	if err != nil {
+		sw.Logger.Error("Failed to get address for inbound peer",
+			"peer", peer, "err", err)
+		return nil, err
+	}
+	return addr, nil
 }
 
 // StopPeerGracefully disconnects from a peer gracefully.
@@ -398,6 +423,7 @@ func (sw *Switch) StopPeerGracefully(peer Peer) {
 
 func (sw *Switch) stopAndRemovePeer(peer Peer, reason interface{}) {
 	sw.transport.Cleanup(peer)
+	schema.WritePeerUpdate(sw.traceClient, string(peer.ID()), schema.PeerDisconnect, fmt.Sprintf("%v", reason))
 	if err := peer.Stop(); err != nil {
 		sw.Logger.Error("error while stopping peer", "error", err) // TODO: should return error to be handled accordingly
 	}
@@ -883,6 +909,7 @@ func (sw *Switch) addPeer(p Peer) error {
 		return err
 	}
 	sw.metrics.Peers.Add(float64(1))
+	schema.WritePeerUpdate(sw.traceClient, string(p.ID()), schema.PeerJoin, "")
 
 	// Start all the reactor protocols on the peer.
 	for _, reactor := range sw.reactors {
