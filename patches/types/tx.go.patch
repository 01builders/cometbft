diff --git a/types/tx.go b/types/tx.go
index ddb59dfe5..e6d750564 100644
--- a/types/tx.go
+++ b/types/tx.go
@@ -6,9 +6,11 @@ import (
 	"errors"
 	"fmt"
 
+	"github.com/gogo/protobuf/proto"
 	"github.com/tendermint/tendermint/crypto/merkle"
 	"github.com/tendermint/tendermint/crypto/tmhash"
 	cmtbytes "github.com/tendermint/tendermint/libs/bytes"
+	"github.com/tendermint/tendermint/pkg/consts"
 	cmtproto "github.com/tendermint/tendermint/proto/tendermint/types"
 )
 
@@ -25,12 +27,27 @@ type (
 	TxKey [TxKeySize]byte
 )
 
-// Hash computes the TMHASH hash of the wire encoded transaction.
+// Hash computes the TMHASH hash of the wire encoded transaction. It attempts to
+// unwrap the transaction if it is a IndexWrapper or a BlobTx.
 func (tx Tx) Hash() []byte {
+	if indexWrapper, isIndexWrapper := UnmarshalIndexWrapper(tx); isIndexWrapper {
+		return tmhash.Sum(indexWrapper.Tx)
+	}
+	if blobTx, isBlobTx := UnmarshalBlobTx(tx); isBlobTx {
+		return tmhash.Sum(blobTx.Tx)
+	}
 	return tmhash.Sum(tx)
 }
 
+// Key returns the sha256 hash of the wire encoded transaction. It attempts to
+// unwrap the transaction if it is a BlobTx or a IndexWrapper.
 func (tx Tx) Key() TxKey {
+	if blobTx, isBlobTx := UnmarshalBlobTx(tx); isBlobTx {
+		return sha256.Sum256(blobTx.Tx)
+	}
+	if indexWrapper, isIndexWrapper := UnmarshalIndexWrapper(tx); isIndexWrapper {
+		return sha256.Sum256(indexWrapper.Tx)
+	}
 	return sha256.Sum256(tx)
 }
 
@@ -39,6 +56,19 @@ func (tx Tx) String() string {
 	return fmt.Sprintf("Tx{%X}", []byte(tx))
 }
 
+func (key TxKey) String() string {
+	return fmt.Sprintf("TxKey{%X}", key[:])
+}
+
+func TxKeyFromBytes(bytes []byte) (TxKey, error) {
+	if len(bytes) != TxKeySize {
+		return TxKey{}, fmt.Errorf("incorrect tx key size. Expected %d bytes, got %d", TxKeySize, len(bytes))
+	}
+	var key TxKey
+	copy(key[:], bytes)
+	return key, nil
+}
+
 // Txs is a slice of Tx.
 type Txs []Tx
 
@@ -74,6 +104,27 @@ func (txs Txs) IndexByHash(hash []byte) int {
 	return -1
 }
 
+// ToSliceOfBytes converts a Txs to slice of byte slices.
+//
+// NOTE: This method should become obsolete once Txs is switched to [][]byte.
+// ref: #2603 https://github.com/tendermint/tendermint/issues/2603
+func (txs Txs) ToSliceOfBytes() [][]byte {
+	txBzs := make([][]byte, len(txs))
+	for i := 0; i < len(txs); i++ {
+		txBzs[i] = txs[i]
+	}
+	return txBzs
+}
+
+// ToTxs converts a raw slice of byte slices into a Txs type.
+func ToTxs(txs [][]byte) Txs {
+	txBzs := make(Txs, len(txs))
+	for i := 0; i < len(txs); i++ {
+		txBzs[i] = txs[i]
+	}
+	return txBzs
+}
+
 // Proof returns a simple merkle proof for this node.
 // Panics if i < 0 or i >= len(txs)
 // TODO: optimize this!
@@ -158,3 +209,73 @@ func ComputeProtoSizeForTxs(txs []Tx) int64 {
 	pdData := data.ToProto()
 	return int64(pdData.Size())
 }
+
+// UnmarshalIndexWrapper attempts to unmarshal the provided transaction into an
+// IndexWrapper transaction. It returns true if the provided transaction is an
+// IndexWrapper transaction. An IndexWrapper transaction is a transaction that contains
+// a MsgPayForBlob that has been wrapped with a share index.
+//
+// NOTE: protobuf sometimes does not throw an error if the transaction passed is
+// not a tmproto.IndexWrapper, since the protobuf definition for MsgPayForBlob is
+// kept in the app, we cannot perform further checks without creating an import
+// cycle.
+func UnmarshalIndexWrapper(tx Tx) (indexWrapper cmtproto.IndexWrapper, isIndexWrapper bool) {
+	// attempt to unmarshal into an IndexWrapper transaction
+	err := proto.Unmarshal(tx, &indexWrapper)
+	if err != nil {
+		return indexWrapper, false
+	}
+	if indexWrapper.TypeId != consts.ProtoIndexWrapperTypeID {
+		return indexWrapper, false
+	}
+	return indexWrapper, true
+}
+
+// MarshalIndexWrapper creates a wrapped Tx that includes the original transaction
+// and the share index of the start of its blob.
+//
+// NOTE: must be unwrapped to be a viable sdk.Tx
+func MarshalIndexWrapper(tx Tx, shareIndexes ...uint32) (Tx, error) {
+	wTx := cmtproto.IndexWrapper{
+		Tx:           tx,
+		ShareIndexes: shareIndexes,
+		TypeId:       consts.ProtoIndexWrapperTypeID,
+	}
+	return proto.Marshal(&wTx)
+}
+
+// UnmarshalBlobTx attempts to unmarshal a transaction into blob transaction. If an
+// error is thrown, false is returned.
+func UnmarshalBlobTx(tx Tx) (bTx cmtproto.BlobTx, isBlob bool) {
+	err := bTx.Unmarshal(tx)
+	if err != nil {
+		return cmtproto.BlobTx{}, false
+	}
+	// perform some quick basic checks to prevent false positives
+	if bTx.TypeId != consts.ProtoBlobTxTypeID {
+		return bTx, false
+	}
+	if len(bTx.Blobs) == 0 {
+		return bTx, false
+	}
+	for _, b := range bTx.Blobs {
+		if len(b.NamespaceId) != consts.NamespaceIDSize {
+			return bTx, false
+		}
+	}
+	return bTx, true
+}
+
+// MarshalBlobTx creates a BlobTx using a normal transaction and some number of
+// blobs.
+//
+// NOTE: Any checks on the blobs or the transaction must be performed in the
+// application
+func MarshalBlobTx(tx []byte, blobs ...*cmtproto.Blob) (Tx, error) {
+	bTx := cmtproto.BlobTx{
+		Tx:     tx,
+		Blobs:  blobs,
+		TypeId: consts.ProtoBlobTxTypeID,
+	}
+	return bTx.Marshal()
+}
