diff --git a/p2p/peer.go b/p2p/peer.go
index 49c0dd4e4..bb04cd36c 100644
--- a/p2p/peer.go
+++ b/p2p/peer.go
@@ -11,6 +11,8 @@ import (
 	"github.com/tendermint/tendermint/libs/cmap"
 	"github.com/tendermint/tendermint/libs/log"
 	"github.com/tendermint/tendermint/libs/service"
+	"github.com/tendermint/tendermint/pkg/trace"
+	"github.com/tendermint/tendermint/pkg/trace/schema"
 
 	cmtconn "github.com/tendermint/tendermint/p2p/conn"
 )
@@ -30,6 +32,8 @@ type Peer interface {
 	IsOutbound() bool   // did we dial the peer
 	IsPersistent() bool // do we redial this peer when we disconnect
 
+	HasIPChanged() bool // has the peer's IP changed
+
 	CloseConn() error // close original connection
 
 	NodeInfo() NodeInfo // peer's info
@@ -175,6 +179,7 @@ type peer struct {
 	Data *cmap.CMap
 
 	metrics       *Metrics
+	traceClient   trace.Tracer
 	metricsTicker *time.Ticker
 	mlc           *metricsLabelCache
 
@@ -184,6 +189,12 @@ type peer struct {
 
 type PeerOption func(*peer)
 
+func WithPeerTracer(t trace.Tracer) PeerOption {
+	return func(p *peer) {
+		p.traceClient = t
+	}
+}
+
 func newPeer(
 	pc peerConn,
 	mConfig cmtconn.MConnConfig,
@@ -203,6 +214,7 @@ func newPeer(
 		metricsTicker: time.NewTicker(metricsTickerDuration),
 		metrics:       NopMetrics(),
 		mlc:           mlc,
+		traceClient:   trace.NoOpTracer(),
 	}
 
 	p.mconn = createMConnection(
@@ -290,6 +302,18 @@ func (p *peer) IsPersistent() bool {
 	return p.peerConn.persistent
 }
 
+// HasIPChanged returns true and the new IP if the peer's IP has changed.
+func (p *peer) HasIPChanged() bool {
+	oldIP := p.ip
+	if oldIP == nil {
+		return false
+	}
+	// Reset the IP so we can get the new one
+	p.ip = nil
+	newIP := p.RemoteIP()
+	return !oldIP.Equal(newIP)
+}
+
 // NodeInfo returns a copy of the peer's NodeInfo.
 func (p *peer) NodeInfo() NodeInfo {
 	return p.nodeInfo
@@ -331,7 +355,12 @@ func (p *peer) SendEnvelope(e Envelope) bool {
 	}
 	res := p.Send(e.ChannelID, msgBytes)
 	if res {
-		p.metrics.MessageSendBytesTotal.With("message_type", metricLabelValue).Add(float64(len(msgBytes)))
+		labels := []string{
+			"message_type", metricLabelValue,
+			"chID", fmt.Sprintf("%#x", e.ChannelID),
+			"peer_id", string(p.ID()),
+		}
+		p.metrics.MessageSendBytesTotal.With(labels...).Add(float64(len(msgBytes)))
 	}
 	return res
 }
@@ -380,7 +409,12 @@ func (p *peer) TrySendEnvelope(e Envelope) bool {
 	}
 	res := p.TrySend(e.ChannelID, msgBytes)
 	if res {
-		p.metrics.MessageSendBytesTotal.With("message_type", metricLabelValue).Add(float64(len(msgBytes)))
+		labels := []string{
+			"message_type", metricLabelValue,
+			"chID", fmt.Sprintf("%#x", e.ChannelID),
+			"peer_id", string(p.ID()),
+		}
+		p.metrics.MessageSendBytesTotal.With(labels...).Add(float64(len(msgBytes)))
 	}
 	return res
 }
@@ -484,11 +518,14 @@ func (p *peer) metricsReporter() {
 		case <-p.metricsTicker.C:
 			status := p.mconn.Status()
 			var sendQueueSize float64
+			queues := make(map[byte]int, len(status.Channels))
 			for _, chStatus := range status.Channels {
 				sendQueueSize += float64(chStatus.SendQueueSize)
+				queues[chStatus.ID] = chStatus.SendQueueSize
 			}
 
 			p.metrics.PeerPendingSendBytes.With("peer_id", string(p.ID())).Set(sendQueueSize)
+			schema.WritePendingBytes(p.traceClient, string(p.ID()), queues)
 		case <-p.Quit():
 			return
 		}
@@ -521,18 +558,22 @@ func createMConnection(
 		if err != nil {
 			panic(fmt.Errorf("unmarshaling message: %s into type: %s", err, reflect.TypeOf(mt)))
 		}
-		labels := []string{
-			"peer_id", string(p.ID()),
-			"chID", fmt.Sprintf("%#x", chID),
-		}
+
 		if w, ok := msg.(Unwrapper); ok {
 			msg, err = w.Unwrap()
 			if err != nil {
 				panic(fmt.Errorf("unwrapping message: %s", err))
 			}
 		}
+
+		labels := []string{
+			"peer_id", string(p.ID()),
+			"chID", fmt.Sprintf("%#x", chID),
+		}
+
 		p.metrics.PeerReceiveBytesTotal.With(labels...).Add(float64(len(msgBytes)))
-		p.metrics.MessageReceiveBytesTotal.With("message_type", p.mlc.ValueToMetricLabel(msg)).Add(float64(len(msgBytes)))
+		p.metrics.MessageReceiveBytesTotal.With(append(labels, "message_type", p.mlc.ValueToMetricLabel(msg))...).Add(float64(len(msgBytes)))
+		schema.WriteReceivedBytes(p.traceClient, string(p.ID()), chID, len(msgBytes))
 		if nr, ok := reactor.(EnvelopeReceiver); ok {
 			nr.ReceiveEnvelope(Envelope{
 				ChannelID: chID,
