diff --git a/mempool/v1/mempool.go b/mempool/v1/mempool.go
index 5fea34964..cc4136e3c 100644
--- a/mempool/v1/mempool.go
+++ b/mempool/v1/mempool.go
@@ -2,19 +2,17 @@ package v1
 
 import (
 	"fmt"
-	"runtime"
 	"sort"
 	"sync"
 	"sync/atomic"
 	"time"
 
-	"github.com/creachadair/taskgroup"
-
 	abci "github.com/tendermint/tendermint/abci/types"
 	"github.com/tendermint/tendermint/config"
 	"github.com/tendermint/tendermint/libs/clist"
 	"github.com/tendermint/tendermint/libs/log"
 	"github.com/tendermint/tendermint/mempool"
+	"github.com/tendermint/tendermint/pkg/trace"
 	"github.com/tendermint/tendermint/proxy"
 	"github.com/tendermint/tendermint/types"
 )
@@ -48,13 +46,17 @@ type TxMempool struct {
 	mtx                  *sync.RWMutex
 	notifiedTxsAvailable bool
 	txsAvailable         chan struct{} // one value sent per height when mempool is not empty
-	preCheck             mempool.PreCheckFunc
-	postCheck            mempool.PostCheckFunc
-	height               int64 // the latest height passed to Update
+	preCheckFn           mempool.PreCheckFunc
+	postCheckFn          mempool.PostCheckFunc
+	height               int64     // the latest height passed to Update
+	lastPurgeTime        time.Time // the last time we attempted to purge transactions via the TTL
 
 	txs        *clist.CList // valid transactions (passed CheckTx)
 	txByKey    map[types.TxKey]*clist.CElement
 	txBySender map[string]*clist.CElement // for sender != ""
+	evictedTxs mempool.TxCache            // for tracking evicted transactions
+
+	traceClient trace.Tracer
 }
 
 // NewTxMempool constructs a new, empty priority mempool at the specified
@@ -78,9 +80,11 @@ func NewTxMempool(
 		height:       height,
 		txByKey:      make(map[types.TxKey]*clist.CElement),
 		txBySender:   make(map[string]*clist.CElement),
+		traceClient:  trace.NoOpTracer(),
 	}
 	if cfg.CacheSize > 0 {
 		txmp.cache = mempool.NewLRUTxCache(cfg.CacheSize)
+		txmp.evictedTxs = mempool.NewLRUTxCache(cfg.CacheSize / 5)
 	}
 
 	for _, opt := range options {
@@ -94,14 +98,14 @@ func NewTxMempool(
 // returns an error. This is executed before CheckTx. It only applies to the
 // first created block. After that, Update() overwrites the existing value.
 func WithPreCheck(f mempool.PreCheckFunc) TxMempoolOption {
-	return func(txmp *TxMempool) { txmp.preCheck = f }
+	return func(txmp *TxMempool) { txmp.preCheckFn = f }
 }
 
 // WithPostCheck sets a filter for the mempool to reject a transaction if
 // f(tx, resp) returns an error. This is executed after CheckTx. It only applies
 // to the first created block. After that, Update overwrites the existing value.
 func WithPostCheck(f mempool.PostCheckFunc) TxMempoolOption {
-	return func(txmp *TxMempool) { txmp.postCheck = f }
+	return func(txmp *TxMempool) { txmp.postCheckFn = f }
 }
 
 // WithMetrics sets the mempool's metrics collector.
@@ -109,6 +113,12 @@ func WithMetrics(metrics *mempool.Metrics) TxMempoolOption {
 	return func(txmp *TxMempool) { txmp.metrics = metrics }
 }
 
+func WithTraceClient(tc trace.Tracer) TxMempoolOption {
+	return func(txmp *TxMempool) {
+		txmp.traceClient = tc
+	}
+}
+
 // Lock obtains a write-lock on the mempool. A caller must be sure to explicitly
 // release the lock when finished.
 func (txmp *TxMempool) Lock() { txmp.mtx.Lock() }
@@ -175,48 +185,42 @@ func (txmp *TxMempool) TxsAvailable() <-chan struct{} { return txmp.txsAvailable
 // the size of tx, and adds tx instead. If no such transactions exist, tx is
 // discarded.
 func (txmp *TxMempool) CheckTx(tx types.Tx, cb func(*abci.Response), txInfo mempool.TxInfo) error {
-
 	// During the initial phase of CheckTx, we do not need to modify any state.
-	// A transaction will not actually be added to the mempool until it survives
-	// a call to the ABCI CheckTx method and size constraint checks.
-	height, err := func() (int64, error) {
-		txmp.mtx.RLock()
-		defer txmp.mtx.RUnlock()
-
-		// Reject transactions in excess of the configured maximum transaction size.
-		if len(tx) > txmp.config.MaxTxBytes {
-			return 0, mempool.ErrTxTooLarge{Max: txmp.config.MaxTxBytes, Actual: len(tx)}
-		}
 
-		// If a precheck hook is defined, call it before invoking the application.
-		if txmp.preCheck != nil {
-			if err := txmp.preCheck(tx); err != nil {
-				return 0, mempool.ErrPreCheck{Reason: err}
-			}
-		}
+	// Reject transactions in excess of the configured maximum transaction size.
+	if len(tx) > txmp.config.MaxTxBytes {
+		return mempool.ErrTxTooLarge{Max: txmp.config.MaxTxBytes, Actual: len(tx)}
+	}
 
-		// Early exit if the proxy connection has an error.
-		if err := txmp.proxyAppConn.Error(); err != nil {
-			return 0, err
-		}
+	// If a precheck hook is defined, call it before invoking the application.
+	if err := txmp.preCheck(tx); err != nil {
+		txmp.metrics.FailedTxs.Add(1)
+		return mempool.ErrPreCheck{Reason: err}
+	}
 
-		txKey := tx.Key()
+	// Early exit if the proxy connection has an error.
+	if err := txmp.proxyAppConn.Error(); err != nil {
+		return err
+	}
 
-		// Check for the transaction in the cache.
-		if !txmp.cache.Push(tx) {
-			// If the cached transaction is also in the pool, record its sender.
-			if elt, ok := txmp.txByKey[txKey]; ok {
-				w := elt.Value.(*WrappedTx)
-				w.SetPeer(txInfo.SenderID)
-			}
-			return 0, mempool.ErrTxInCache
+	txKey := tx.Key()
+
+	// Check for the transaction in the cache.
+	if !txmp.cache.Push(tx) {
+		// If the cached transaction is also in the pool, record its sender.
+		if elt, ok := txmp.txByKey[txKey]; ok {
+			txmp.metrics.AlreadySeenTxs.Add(1)
+			w := elt.Value.(*WrappedTx)
+			w.SetPeer(txInfo.SenderID)
 		}
-		return txmp.height, nil
-	}()
-	if err != nil {
-		return err
+		return mempool.ErrTxInCache
 	}
 
+	// At this point, we need to ensure that passing CheckTx and adding to
+	// the mempool is atomic.
+	txmp.Lock()
+	defer txmp.Unlock()
+
 	// Invoke an ABCI CheckTx for this transaction.
 	rsp, err := txmp.proxyAppConn.CheckTxSync(abci.RequestCheckTx{Tx: tx})
 	if err != nil {
@@ -227,9 +231,10 @@ func (txmp *TxMempool) CheckTx(tx types.Tx, cb func(*abci.Response), txInfo memp
 		tx:        tx,
 		hash:      tx.Key(),
 		timestamp: time.Now().UTC(),
-		height:    height,
+		height:    txmp.height,
 	}
 	wtx.SetPeer(txInfo.SenderID)
+	// This won't add the transaction if the response code is non zero (i.e. there was an error)
 	txmp.addNewTransaction(wtx, rsp)
 	if cb != nil {
 		cb(&abci.Response{Value: &abci.Response_CheckTx{CheckTx: rsp}})
@@ -246,6 +251,24 @@ func (txmp *TxMempool) RemoveTxByKey(txKey types.TxKey) error {
 	return txmp.removeTxByKey(txKey)
 }
 
+// GetTxByKey retrieves a transaction based on the key. It returns a bool
+// indicating whether transaction was found in the cache.
+func (txmp *TxMempool) GetTxByKey(txKey types.TxKey) (types.Tx, bool) {
+	txmp.mtx.RLock()
+	defer txmp.mtx.RUnlock()
+
+	if elt, ok := txmp.txByKey[txKey]; ok {
+		return elt.Value.(*WrappedTx).tx, true
+	}
+	return nil, false
+}
+
+// WasRecentlyEvicted returns a bool indicating whether the transaction with
+// the specified key was recently evicted and is currently within the evicted cache.
+func (txmp *TxMempool) WasRecentlyEvicted(txKey types.TxKey) bool {
+	return txmp.evictedTxs.HasKey(txKey)
+}
+
 // removeTxByKey removes the specified transaction key from the mempool.
 // The caller must hold txmp.mtx excluxively.
 func (txmp *TxMempool) removeTxByKey(key types.TxKey) error {
@@ -327,12 +350,14 @@ func (txmp *TxMempool) ReapMaxBytesMaxGas(maxBytes, maxGas int64) types.Txs {
 	var keep []types.Tx //nolint:prealloc
 	for _, w := range txmp.allEntriesSorted() {
 		// N.B. When computing byte size, we need to include the overhead for
-		// encoding as protobuf to send to the application.
-		totalGas += w.gasWanted
-		totalBytes += types.ComputeProtoSizeForTxs([]types.Tx{w.tx})
-		if (maxGas >= 0 && totalGas > maxGas) || (maxBytes >= 0 && totalBytes > maxBytes) {
-			break
+		// encoding as protobuf to send to the application. This actually overestimates it
+		// as we add the proto overhead to each transaction
+		txBytes := types.ComputeProtoSizeForTxs([]types.Tx{w.tx})
+		if (maxGas >= 0 && totalGas+w.gasWanted > maxGas) || (maxBytes >= 0 && totalBytes+txBytes > maxBytes) {
+			continue
 		}
+		totalBytes += txBytes
+		totalGas += w.gasWanted
 		keep = append(keep, w.tx)
 	}
 	return keep
@@ -394,12 +419,13 @@ func (txmp *TxMempool) Update(
 	txmp.notifiedTxsAvailable = false
 
 	if newPreFn != nil {
-		txmp.preCheck = newPreFn
+		txmp.preCheckFn = newPreFn
 	}
 	if newPostFn != nil {
-		txmp.postCheck = newPostFn
+		txmp.postCheckFn = newPostFn
 	}
 
+	txmp.metrics.SuccessfulTxs.Add(float64(len(blockTxs)))
 	for i, tx := range blockTxs {
 		// Add successful committed transactions to the cache (if they are not
 		// already present).  Transactions that failed to commit are removed from
@@ -421,6 +447,7 @@ func (txmp *TxMempool) Update(
 	// transactions are left.
 	size := txmp.Size()
 	txmp.metrics.Size.Set(float64(size))
+	txmp.metrics.SizeBytes.Set(float64(txmp.SizeBytes()))
 	if size > 0 {
 		if txmp.config.Recheck {
 			txmp.recheckTransactions()
@@ -445,12 +472,9 @@ func (txmp *TxMempool) Update(
 //
 // Finally, the new transaction is added and size stats updated.
 func (txmp *TxMempool) addNewTransaction(wtx *WrappedTx, checkTxRes *abci.ResponseCheckTx) {
-	txmp.mtx.Lock()
-	defer txmp.mtx.Unlock()
-
 	var err error
-	if txmp.postCheck != nil {
-		err = txmp.postCheck(wtx.tx, checkTxRes)
+	if txmp.postCheckFn != nil {
+		err = txmp.postCheckFn(wtx.tx, checkTxRes)
 	}
 
 	if err != nil || checkTxRes.Code != abci.CodeTypeOK {
@@ -497,7 +521,6 @@ func (txmp *TxMempool) addNewTransaction(wtx *WrappedTx, checkTxRes *abci.Respon
 			checkTxRes.MempoolError =
 				fmt.Sprintf("rejected valid incoming transaction; tx already exists for sender %q (%X)",
 					sender, w.tx.Hash())
-			txmp.metrics.RejectedTxs.Add(1)
 			return
 		}
 	}
@@ -532,7 +555,9 @@ func (txmp *TxMempool) addNewTransaction(wtx *WrappedTx, checkTxRes *abci.Respon
 			checkTxRes.MempoolError =
 				fmt.Sprintf("rejected valid incoming transaction; mempool is full (%X)",
 					wtx.tx.Hash())
-			txmp.metrics.RejectedTxs.Add(1)
+			txmp.metrics.EvictedTxs.Add(1)
+			// Add it to evicted transactions cache
+			txmp.evictedTxs.Push(wtx.tx)
 			return
 		}
 
@@ -565,7 +590,8 @@ func (txmp *TxMempool) addNewTransaction(wtx *WrappedTx, checkTxRes *abci.Respon
 			txmp.removeTxByElement(vic)
 			txmp.cache.Remove(w.tx)
 			txmp.metrics.EvictedTxs.Add(1)
-
+			// Add it to evicted transactions cache
+			txmp.evictedTxs.Push(w.tx)
 			// We may not need to evict all the eligible transactions.  Bail out
 			// early if we have made enough room.
 			evictedBytes += w.Size()
@@ -582,6 +608,7 @@ func (txmp *TxMempool) addNewTransaction(wtx *WrappedTx, checkTxRes *abci.Respon
 
 	txmp.metrics.TxSizeBytes.Observe(float64(wtx.Size()))
 	txmp.metrics.Size.Set(float64(txmp.Size()))
+	txmp.metrics.SizeBytes.Set(float64(txmp.SizeBytes()))
 	txmp.logger.Debug(
 		"inserted new valid transaction",
 		"priority", wtx.Priority(),
@@ -610,8 +637,6 @@ func (txmp *TxMempool) insertTx(wtx *WrappedTx) {
 // that case is handled by addNewTransaction instead.
 func (txmp *TxMempool) handleRecheckResult(tx types.Tx, checkTxRes *abci.ResponseCheckTx) {
 	txmp.metrics.RecheckTimes.Add(1)
-	txmp.mtx.Lock()
-	defer txmp.mtx.Unlock()
 
 	// Find the transaction reported by the ABCI callback. It is possible the
 	// transaction was evicted during the recheck, in which case the transaction
@@ -624,8 +649,8 @@ func (txmp *TxMempool) handleRecheckResult(tx types.Tx, checkTxRes *abci.Respons
 
 	// If a postcheck hook is defined, call it before checking the result.
 	var err error
-	if txmp.postCheck != nil {
-		err = txmp.postCheck(tx, checkTxRes)
+	if txmp.postCheckFn != nil {
+		err = txmp.postCheckFn(tx, checkTxRes)
 	}
 
 	if checkTxRes.Code == abci.CodeTypeOK && err == nil {
@@ -646,6 +671,7 @@ func (txmp *TxMempool) handleRecheckResult(tx types.Tx, checkTxRes *abci.Respons
 		txmp.cache.Remove(wtx.tx)
 	}
 	txmp.metrics.Size.Set(float64(txmp.Size()))
+	txmp.metrics.SizeBytes.Set(float64(txmp.SizeBytes()))
 }
 
 // recheckTransactions initiates re-CheckTx ABCI calls for all the transactions
@@ -672,34 +698,23 @@ func (txmp *TxMempool) recheckTransactions() {
 
 	// Issue CheckTx calls for each remaining transaction, and when all the
 	// rechecks are complete signal watchers that transactions may be available.
-	go func() {
-		g, start := taskgroup.New(nil).Limit(2 * runtime.NumCPU())
-
-		for _, wtx := range wtxs {
-			wtx := wtx
-			start(func() error {
-				// The response for this CheckTx is handled by the default recheckTxCallback.
-				rsp, err := txmp.proxyAppConn.CheckTxSync(abci.RequestCheckTx{
-					Tx:   wtx.tx,
-					Type: abci.CheckTxType_Recheck,
-				})
-				if err != nil {
-					txmp.logger.Error("failed to execute CheckTx during recheck",
-						"err", err, "hash", fmt.Sprintf("%x", wtx.tx.Hash()))
-				} else {
-					txmp.handleRecheckResult(wtx.tx, rsp)
-				}
-				return nil
-			})
+	for _, wtx := range wtxs {
+		wtx := wtx
+		// The response for this CheckTx is handled by the default recheckTxCallback.
+		rsp, err := txmp.proxyAppConn.CheckTxSync(abci.RequestCheckTx{
+			Tx:   wtx.tx,
+			Type: abci.CheckTxType_Recheck,
+		})
+		if err != nil {
+			txmp.logger.Error("failed to execute CheckTx during recheck",
+				"err", err, "hash", fmt.Sprintf("%x", wtx.tx.Hash()))
+		} else {
+			txmp.handleRecheckResult(wtx.tx, rsp)
 		}
-		_ = txmp.proxyAppConn.FlushAsync()
-
-		// When recheck is complete, trigger a notification for more transactions.
-		_ = g.Wait()
-		txmp.mtx.Lock()
-		defer txmp.mtx.Unlock()
-		txmp.notifyTxsAvailable()
-	}()
+	}
+	_ = txmp.proxyAppConn.FlushAsync()
+
+	txmp.notifyTxsAvailable()
 }
 
 // canAddTx returns an error if we cannot insert the provided *WrappedTx into
@@ -721,6 +736,17 @@ func (txmp *TxMempool) canAddTx(wtx *WrappedTx) error {
 	return nil
 }
 
+// CheckToPurgeExpiredTxs checks if there has been adequate time since the last time
+// the txpool looped through all transactions and if so, performs a purge of any transaction
+// that has expired according to the TTLDuration. This is thread safe.
+func (txmp *TxMempool) CheckToPurgeExpiredTxs() {
+	txmp.mtx.Lock()
+	defer txmp.mtx.Unlock()
+	if txmp.config.TTLDuration > 0 && time.Since(txmp.lastPurgeTime) > txmp.config.TTLDuration {
+		txmp.purgeExpiredTxs(txmp.height)
+	}
+}
+
 // purgeExpiredTxs removes all transactions from the mempool that have exceeded
 // their respective height or time-based limits as of the given blockHeight.
 // Transactions removed by this operation are not removed from the cache.
@@ -739,17 +765,17 @@ func (txmp *TxMempool) purgeExpiredTxs(blockHeight int64) {
 		next := cur.Next()
 
 		w := cur.Value.(*WrappedTx)
-		if txmp.config.TTLNumBlocks > 0 && (blockHeight-w.height) > txmp.config.TTLNumBlocks {
+		if txmp.config.TTLNumBlocks > 0 && (blockHeight-w.height) > txmp.config.TTLNumBlocks ||
+			txmp.config.TTLDuration > 0 && now.Sub(w.timestamp) > txmp.config.TTLDuration {
 			txmp.removeTxByElement(cur)
 			txmp.cache.Remove(w.tx)
-			txmp.metrics.EvictedTxs.Add(1)
-		} else if txmp.config.TTLDuration > 0 && now.Sub(w.timestamp) > txmp.config.TTLDuration {
-			txmp.removeTxByElement(cur)
-			txmp.cache.Remove(w.tx)
-			txmp.metrics.EvictedTxs.Add(1)
+			txmp.evictedTxs.Push(w.tx)
+			txmp.metrics.ExpiredTxs.Add(1)
 		}
 		cur = next
 	}
+
+	txmp.lastPurgeTime = now
 }
 
 func (txmp *TxMempool) notifyTxsAvailable() {
@@ -767,3 +793,12 @@ func (txmp *TxMempool) notifyTxsAvailable() {
 		}
 	}
 }
+
+func (txmp *TxMempool) preCheck(tx types.Tx) error {
+	txmp.mtx.Lock()
+	defer txmp.mtx.Unlock()
+	if txmp.preCheckFn != nil {
+		return txmp.preCheckFn(tx)
+	}
+	return nil
+}
