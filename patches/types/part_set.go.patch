diff --git a/types/part_set.go b/types/part_set.go
index 4b1422789..756acfb16 100644
--- a/types/part_set.go
+++ b/types/part_set.go
@@ -37,6 +37,9 @@ func (part *Part) ValidateBasic() error {
 	if int64(part.Index) < part.Proof.Total-1 && len(part.Bytes) != int(BlockPartSizeBytes) {
 		return ErrPartInvalidSize
 	}
+	if int64(part.Index) != part.Proof.Index {
+		return fmt.Errorf("part index %d != proof index %d", part.Index, part.Proof.Index)
+	}
 	if err := part.Proof.ValidateBasic(); err != nil {
 		return fmt.Errorf("wrong Proof: %w", err)
 	}
@@ -171,6 +174,7 @@ type PartSet struct {
 // CONTRACT: partSize is greater than zero.
 func NewPartSetFromData(data []byte, partSize uint32) *PartSet {
 	// divide data into 4kb parts.
+	//nolint:gosec
 	total := (uint32(len(data)) + partSize - 1) / partSize
 	parts := make([]*Part, total)
 	partsBytes := make([][]byte, total)
@@ -270,6 +274,27 @@ func (ps *PartSet) Total() uint32 {
 }
 
 func (ps *PartSet) AddPart(part *Part) (bool, error) {
+	if part == nil {
+		return false, fmt.Errorf("nil part")
+	}
+
+	// The proof should be compatible with the number of parts.
+	if part.Proof.Total != int64(ps.total) {
+		return false, ErrPartSetInvalidProof
+	}
+
+	// Check hash proof
+	if part.Proof.Verify(ps.Hash(), part.Bytes) != nil {
+		return false, ErrPartSetInvalidProof
+	}
+
+	return ps.AddPartWithoutProof(part)
+}
+
+func (ps *PartSet) AddPartWithoutProof(part *Part) (bool, error) {
+	if part == nil {
+		return false, fmt.Errorf("nil part")
+	}
 	if ps == nil {
 		return false, nil
 	}
@@ -286,16 +311,6 @@ func (ps *PartSet) AddPart(part *Part) (bool, error) {
 		return false, nil
 	}
 
-	// The proof should be compatible with the number of parts.
-	if part.Proof.Total != int64(ps.total) {
-		return false, ErrPartSetInvalidProof
-	}
-
-	// Check hash proof
-	if part.Proof.Verify(ps.Hash(), part.Bytes) != nil {
-		return false, ErrPartSetInvalidProof
-	}
-
 	// Add part
 	ps.parts[part.Index] = part
 	ps.partsBitArray.SetIndex(int(part.Index), true)
