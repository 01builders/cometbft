diff --git a/store/store.go b/store/store.go
index 3a2fd1aa7..5ddea3bbf 100644
--- a/store/store.go
+++ b/store/store.go
@@ -7,6 +7,7 @@ import (
 	dbm "github.com/cometbft/cometbft-db"
 	"github.com/gogo/protobuf/proto"
 
+	abci "github.com/tendermint/tendermint/abci/types"
 	cmtsync "github.com/tendermint/tendermint/libs/sync"
 	cmtstore "github.com/tendermint/tendermint/proto/tendermint/store"
 	cmtproto "github.com/tendermint/tendermint/proto/tendermint/types"
@@ -37,7 +38,7 @@ type BlockStore struct {
 	// fine-grained concurrency control for its data, and thus this mutex does not apply to
 	// database contents. The only reason for keeping these fields in the struct is that the data
 	// can't efficiently be queried from the database since the key encoding we use is not
-	// lexicographically ordered (see https://github.com/tendermint/tendermint/issues/4567).
+	// lexicographically ordered.
 	mtx    cmtsync.RWMutex
 	base   int64
 	height int64
@@ -78,7 +79,7 @@ func (bs *BlockStore) Size() int64 {
 	return bs.height - bs.base + 1
 }
 
-// LoadBase atomically loads the base block meta, or returns nil if no base is found.
+// LoadBaseMeta atomically loads the base block meta, or returns nil if no base is found.
 func (bs *BlockStore) LoadBaseMeta() *types.BlockMeta {
 	bs.mtx.RLock()
 	defer bs.mtx.RUnlock()
@@ -196,6 +197,25 @@ func (bs *BlockStore) LoadBlockMeta(height int64) *types.BlockMeta {
 	return blockMeta
 }
 
+// LoadBlockMetaByHash returns the blockmeta whose header corresponds to the given hash. If none is found, returns nil.
+func (bs *BlockStore) LoadBlockMetaByHash(hash []byte) *types.BlockMeta {
+	bz, err := bs.db.Get(calcBlockHashKey(hash))
+	if err != nil {
+		panic(err)
+	}
+	if len(bz) == 0 {
+		return nil
+	}
+
+	s := string(bz)
+	height, err := strconv.ParseInt(s, 10, 64)
+
+	if err != nil {
+		panic(fmt.Sprintf("failed to extract height from %s: %v", s, err))
+	}
+	return bs.LoadBlockMeta(height)
+}
+
 // LoadBlockCommit returns the Commit for the given height.
 // This commit consists of the +2/3 and other Precommit-votes for block at `height`,
 // and it comes from the block.LastCommit for `height+1`.
@@ -272,8 +292,7 @@ func (bs *BlockStore) PruneBlocks(height int64) (uint64, error) {
 		bs.mtx.Unlock()
 		bs.saveState()
 
-		err := batch.WriteSync()
-		if err != nil {
+		if err := batch.WriteSync(); err != nil {
 			return fmt.Errorf("failed to prune up to height %v: %w", base, err)
 		}
 		batch.Close()
@@ -285,6 +304,12 @@ func (bs *BlockStore) PruneBlocks(height int64) (uint64, error) {
 		if meta == nil { // assume already deleted
 			continue
 		}
+		block := bs.LoadBlock(h)
+		for _, tx := range block.Txs {
+			if err := batch.Delete(calcTxHashKey(tx.Hash())); err != nil {
+				return 0, err
+			}
+		}
 		if err := batch.Delete(calcBlockMetaKey(h)); err != nil {
 			return 0, err
 		}
@@ -425,6 +450,44 @@ func (bs *BlockStore) SaveSeenCommit(height int64, seenCommit *types.Commit) err
 	return bs.db.Set(calcSeenCommitKey(height), seenCommitBytes)
 }
 
+// SaveTxInfo indexes the txs from the block with the given response codes and logs from execution.
+// Only the error logs are saved for failed transactions.
+func (bs *BlockStore) SaveTxInfo(block *types.Block, txResponseCodes []uint32, logs []string) error {
+	if len(txResponseCodes) != len(block.Txs) {
+		return fmt.Errorf("txResponseCodes length mismatch with block txs length")
+	}
+	if len(logs) != len(block.Txs) {
+		return fmt.Errorf("logs length mismatch with block txs length")
+	}
+
+	// Create a new batch
+	batch := bs.db.NewBatch()
+
+	// Batch and save txs from the block
+	for i, tx := range block.Txs {
+		txInfo := cmtstore.TxInfo{
+			Height: block.Height,
+			//nolint:gosec
+			Index: uint32(i),
+			Code:  txResponseCodes[i],
+		}
+		// Set error log for failed txs
+		if txResponseCodes[i] != abci.CodeTypeOK {
+			txInfo.Error = logs[i]
+		}
+		txInfoBytes, err := proto.Marshal(&txInfo)
+		if err != nil {
+			return fmt.Errorf("unable to marshal tx: %w", err)
+		}
+		if err := batch.Set(calcTxHashKey(tx.Hash()), txInfoBytes); err != nil {
+			return err
+		}
+	}
+
+	// Write the batch to the db
+	return batch.WriteSync()
+}
+
 func (bs *BlockStore) Close() error {
 	return bs.db.Close()
 }
@@ -451,6 +514,10 @@ func calcBlockHashKey(hash []byte) []byte {
 	return []byte(fmt.Sprintf("BH:%x", hash))
 }
 
+func calcTxHashKey(hash []byte) []byte {
+	return []byte(fmt.Sprintf("TH:%x", hash))
+}
+
 //-----------------------------------------------------------------------------
 
 var blockStoreKey = []byte("blockStore")
@@ -493,6 +560,23 @@ func LoadBlockStoreState(db dbm.DB) cmtstore.BlockStoreState {
 	return bsj
 }
 
+// LoadTxInfo loads the TxInfo from disk given its hash.
+func (bs *BlockStore) LoadTxInfo(txHash []byte) *cmtstore.TxInfo {
+	bz, err := bs.db.Get(calcTxHashKey(txHash))
+	if err != nil {
+		panic(err)
+	}
+	if len(bz) == 0 {
+		return nil
+	}
+
+	var txi cmtstore.TxInfo
+	if err = proto.Unmarshal(bz, &txi); err != nil {
+		panic(fmt.Errorf("unmarshal to TxInfo failed: %w", err))
+	}
+	return &txi
+}
+
 // mustEncode proto encodes a proto.message and panics if fails
 func mustEncode(pb proto.Message) []byte {
 	bz, err := proto.Marshal(pb)
