diff --git a/mempool/v0/clist_mempool.go b/mempool/v0/clist_mempool.go
index df905a5e9..8d8b63730 100644
--- a/mempool/v0/clist_mempool.go
+++ b/mempool/v0/clist_mempool.go
@@ -183,6 +183,21 @@ func (mem *CListMempool) TxsFront() *clist.CElement {
 	return mem.txs.Front()
 }
 
+// GetTxByKey retrieves a transaction from the mempool using its key.
+func (mem *CListMempool) GetTxByKey(key types.TxKey) (types.Tx, bool) {
+	e, ok := mem.txsMap.Load(key)
+	if !ok {
+		return nil, false
+	}
+	memTx, ok := e.(*clist.CElement).Value.(*mempoolTx)
+	return memTx.tx, ok
+}
+
+// WasRecentlyEvicted returns false consistently as this implementation does not support transaction eviction.
+func (mem *CListMempool) WasRecentlyEvicted(key types.TxKey) bool {
+	return false
+}
+
 // TxsWaitChan returns a channel to wait on transactions. It will be closed
 // once the mempool is not empty (ie. the internal `mem.txs` has at least one
 // element)
@@ -242,6 +257,7 @@ func (mem *CListMempool) CheckTx(
 		// (eg. after committing a block, txs are removed from mempool but not cache),
 		// so we only record the sender for txs still in the mempool.
 		if e, ok := mem.txsMap.Load(tx.Key()); ok {
+			mem.metrics.AlreadySeenTxs.Add(1)
 			memTx := e.(*clist.CElement).Value.(*mempoolTx)
 			memTx.senders.LoadOrStore(txInfo.SenderID, true)
 			// TODO: consider punishing peer for dups,
@@ -276,6 +292,7 @@ func (mem *CListMempool) globalCb(req *abci.Request, res *abci.Response) {
 
 	// update metrics
 	mem.metrics.Size.Set(float64(mem.Size()))
+	mem.metrics.SizeBytes.Set(float64(mem.SizeBytes()))
 }
 
 // Request specific callback that should be set on individual reqRes objects
@@ -328,6 +345,9 @@ func (mem *CListMempool) removeTx(tx types.Tx, elem *clist.CElement, removeFromC
 	mem.txs.Remove(elem)
 	elem.DetachPrev()
 	mem.txsMap.Delete(tx.Key())
+	if memtx, ok := elem.Value.(*mempoolTx); ok {
+		tx = memtx.tx
+	}
 	atomic.AddInt64(&mem.txsBytes, int64(-len(tx)))
 
 	if removeFromCache {
@@ -609,6 +629,7 @@ func (mem *CListMempool) Update(
 		mem.postCheck = postCheck
 	}
 
+	mem.metrics.SuccessfulTxs.Add(float64(len(txs)))
 	for i, tx := range txs {
 		if deliverTxResponses[i].Code == abci.CodeTypeOK {
 			// Add valid committed tx to the cache (if missing).
