diff --git a/types/part_set.go b/types/part_set.go
index 4b1422789..010a7cc5e 100644
--- a/types/part_set.go
+++ b/types/part_set.go
@@ -171,6 +171,7 @@ type PartSet struct {
 // CONTRACT: partSize is greater than zero.
 func NewPartSetFromData(data []byte, partSize uint32) *PartSet {
 	// divide data into 4kb parts.
+	//nolint:gosec
 	total := (uint32(len(data)) + partSize - 1) / partSize
 	parts := make([]*Part, total)
 	partsBytes := make([][]byte, total)
@@ -270,6 +271,27 @@ func (ps *PartSet) Total() uint32 {
 }
 
 func (ps *PartSet) AddPart(part *Part) (bool, error) {
+	if part == nil {
+		return false, fmt.Errorf("nil part")
+	}
+
+	// The proof should be compatible with the number of parts.
+	if part.Proof.Total != int64(ps.total) {
+		return false, ErrPartSetInvalidProof
+	}
+
+	// Check hash proof
+	if part.Proof.Verify(ps.Hash(), part.Bytes) != nil {
+		return false, ErrPartSetInvalidProof
+	}
+
+	return ps.AddPartWithoutProof(part)
+}
+
+func (ps *PartSet) AddPartWithoutProof(part *Part) (bool, error) {
+	if part == nil {
+		return false, fmt.Errorf("nil part")
+	}
 	if ps == nil {
 		return false, nil
 	}
@@ -286,16 +308,6 @@ func (ps *PartSet) AddPart(part *Part) (bool, error) {
 		return false, nil
 	}
 
-	// The proof should be compatible with the number of parts.
-	if part.Proof.Total != int64(ps.total) {
-		return false, ErrPartSetInvalidProof
-	}
-
-	// Check hash proof
-	if part.Proof.Verify(ps.Hash(), part.Bytes) != nil {
-		return false, ErrPartSetInvalidProof
-	}
-
 	// Add part
 	ps.parts[part.Index] = part
 	ps.partsBitArray.SetIndex(int(part.Index), true)
