diff --git a/state/mocks/block_store.go b/state/mocks/block_store.go
index 4493a6e3f..eccf9c27d 100644
--- a/state/mocks/block_store.go
+++ b/state/mocks/block_store.go
@@ -5,6 +5,7 @@ package mocks
 import (
 	mock "github.com/stretchr/testify/mock"
 
+	cmtstore "github.com/tendermint/tendermint/proto/tendermint/store"
 	types "github.com/tendermint/tendermint/types"
 )
 
@@ -17,6 +18,10 @@ type BlockStore struct {
 func (_m *BlockStore) Base() int64 {
 	ret := _m.Called()
 
+	if len(ret) == 0 {
+		panic("no return value specified for Base")
+	}
+
 	var r0 int64
 	if rf, ok := ret.Get(0).(func() int64); ok {
 		r0 = rf()
@@ -31,6 +36,10 @@ func (_m *BlockStore) Base() int64 {
 func (_m *BlockStore) Height() int64 {
 	ret := _m.Called()
 
+	if len(ret) == 0 {
+		panic("no return value specified for Height")
+	}
+
 	var r0 int64
 	if rf, ok := ret.Get(0).(func() int64); ok {
 		r0 = rf()
@@ -45,6 +54,10 @@ func (_m *BlockStore) Height() int64 {
 func (_m *BlockStore) LoadBaseMeta() *types.BlockMeta {
 	ret := _m.Called()
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBaseMeta")
+	}
+
 	var r0 *types.BlockMeta
 	if rf, ok := ret.Get(0).(func() *types.BlockMeta); ok {
 		r0 = rf()
@@ -61,6 +74,10 @@ func (_m *BlockStore) LoadBaseMeta() *types.BlockMeta {
 func (_m *BlockStore) LoadBlock(height int64) *types.Block {
 	ret := _m.Called(height)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBlock")
+	}
+
 	var r0 *types.Block
 	if rf, ok := ret.Get(0).(func(int64) *types.Block); ok {
 		r0 = rf(height)
@@ -73,10 +90,30 @@ func (_m *BlockStore) LoadBlock(height int64) *types.Block {
 	return r0
 }
 
+// LoadTxInfo provides a mock function with given fields: hash
+func (_m *BlockStore) LoadTxInfo(hash []byte) *cmtstore.TxInfo {
+	ret := _m.Called(hash)
+
+	var r0 *cmtstore.TxInfo
+	if rf, ok := ret.Get(0).(func([]byte) *cmtstore.TxInfo); ok {
+		r0 = rf(hash)
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(*cmtstore.TxInfo)
+		}
+	}
+
+	return r0
+}
+
 // LoadBlockByHash provides a mock function with given fields: hash
 func (_m *BlockStore) LoadBlockByHash(hash []byte) *types.Block {
 	ret := _m.Called(hash)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBlockByHash")
+	}
+
 	var r0 *types.Block
 	if rf, ok := ret.Get(0).(func([]byte) *types.Block); ok {
 		r0 = rf(hash)
@@ -93,6 +130,10 @@ func (_m *BlockStore) LoadBlockByHash(hash []byte) *types.Block {
 func (_m *BlockStore) LoadBlockCommit(height int64) *types.Commit {
 	ret := _m.Called(height)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBlockCommit")
+	}
+
 	var r0 *types.Commit
 	if rf, ok := ret.Get(0).(func(int64) *types.Commit); ok {
 		r0 = rf(height)
@@ -109,6 +150,10 @@ func (_m *BlockStore) LoadBlockCommit(height int64) *types.Commit {
 func (_m *BlockStore) LoadBlockMeta(height int64) *types.BlockMeta {
 	ret := _m.Called(height)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBlockMeta")
+	}
+
 	var r0 *types.BlockMeta
 	if rf, ok := ret.Get(0).(func(int64) *types.BlockMeta); ok {
 		r0 = rf(height)
@@ -121,10 +166,30 @@ func (_m *BlockStore) LoadBlockMeta(height int64) *types.BlockMeta {
 	return r0
 }
 
+// LoadBlockMetaByHash provides a mock function with given fields: hash
+func (_m *BlockStore) LoadBlockMetaByHash(hash []byte) *types.BlockMeta {
+	ret := _m.Called(hash)
+
+	var r0 *types.BlockMeta
+	if rf, ok := ret.Get(0).(func([]byte) *types.BlockMeta); ok {
+		r0 = rf(hash)
+	} else {
+		if ret.Get(0) != nil {
+			r0 = ret.Get(0).(*types.BlockMeta)
+		}
+	}
+
+	return r0
+}
+
 // LoadBlockPart provides a mock function with given fields: height, index
 func (_m *BlockStore) LoadBlockPart(height int64, index int) *types.Part {
 	ret := _m.Called(height, index)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadBlockPart")
+	}
+
 	var r0 *types.Part
 	if rf, ok := ret.Get(0).(func(int64, int) *types.Part); ok {
 		r0 = rf(height, index)
@@ -141,6 +206,10 @@ func (_m *BlockStore) LoadBlockPart(height int64, index int) *types.Part {
 func (_m *BlockStore) LoadSeenCommit(height int64) *types.Commit {
 	ret := _m.Called(height)
 
+	if len(ret) == 0 {
+		panic("no return value specified for LoadSeenCommit")
+	}
+
 	var r0 *types.Commit
 	if rf, ok := ret.Get(0).(func(int64) *types.Commit); ok {
 		r0 = rf(height)
@@ -157,14 +226,21 @@ func (_m *BlockStore) LoadSeenCommit(height int64) *types.Commit {
 func (_m *BlockStore) PruneBlocks(height int64) (uint64, error) {
 	ret := _m.Called(height)
 
+	if len(ret) == 0 {
+		panic("no return value specified for PruneBlocks")
+	}
+
 	var r0 uint64
+	var r1 error
+	if rf, ok := ret.Get(0).(func(int64) (uint64, error)); ok {
+		return rf(height)
+	}
 	if rf, ok := ret.Get(0).(func(int64) uint64); ok {
 		r0 = rf(height)
 	} else {
 		r0 = ret.Get(0).(uint64)
 	}
 
-	var r1 error
 	if rf, ok := ret.Get(1).(func(int64) error); ok {
 		r1 = rf(height)
 	} else {
@@ -174,6 +250,20 @@ func (_m *BlockStore) PruneBlocks(height int64) (uint64, error) {
 	return r0, r1
 }
 
+// SaveTxInfo provides a mock function with given fields: block, txResponseCode
+func (_m *BlockStore) SaveTxInfo(block *types.Block, txResponseCodes []uint32, logs []string) error {
+	ret := _m.Called(block, txResponseCodes, logs)
+
+	var r0 error
+	if rf, ok := ret.Get(0).(func(*types.Block, []uint32, []string) error); ok {
+		r0 = rf(block, txResponseCodes, logs)
+	} else {
+		r0 = ret.Error(0)
+	}
+
+	return r0
+}
+
 // SaveBlock provides a mock function with given fields: block, blockParts, seenCommit
 func (_m *BlockStore) SaveBlock(block *types.Block, blockParts *types.PartSet, seenCommit *types.Commit) {
 	_m.Called(block, blockParts, seenCommit)
@@ -183,6 +273,10 @@ func (_m *BlockStore) SaveBlock(block *types.Block, blockParts *types.PartSet, s
 func (_m *BlockStore) Size() int64 {
 	ret := _m.Called()
 
+	if len(ret) == 0 {
+		panic("no return value specified for Size")
+	}
+
 	var r0 int64
 	if rf, ok := ret.Get(0).(func() int64); ok {
 		r0 = rf()
@@ -193,13 +287,12 @@ func (_m *BlockStore) Size() int64 {
 	return r0
 }
 
-type mockConstructorTestingTNewBlockStore interface {
+// NewBlockStore creates a new instance of BlockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
+// The first argument is typically a *testing.T value.
+func NewBlockStore(t interface {
 	mock.TestingT
 	Cleanup(func())
-}
-
-// NewBlockStore creates a new instance of BlockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
-func NewBlockStore(t mockConstructorTestingTNewBlockStore) *BlockStore {
+}) *BlockStore {
 	mock := &BlockStore{}
 	mock.Mock.Test(t)
 
