diff --git a/libs/bytes/bytes.go b/libs/bytes/bytes.go
index 95b4cc35f..91a69499b 100644
--- a/libs/bytes/bytes.go
+++ b/libs/bytes/bytes.go
@@ -1,7 +1,9 @@
 package bytes
 
 import (
+	"encoding/binary"
 	"encoding/hex"
+	"encoding/json"
 	"fmt"
 	"strings"
 )
@@ -9,6 +11,19 @@ import (
 // HexBytes enables HEX-encoding for json/encoding.
 type HexBytes []byte
 
+var (
+	_ json.Marshaler   = HexBytes{}
+	_ json.Unmarshaler = &HexBytes{}
+)
+
+func (bz HexBytes) MarshalDelimited() ([]byte, error) {
+	lenBuf := make([]byte, binary.MaxVarintLen64)
+	length := uint64(len(bz))
+	n := binary.PutUvarint(lenBuf, length)
+
+	return append(lenBuf[:n], bz...), nil
+}
+
 // Marshal needed for protobuf compatibility
 func (bz HexBytes) Marshal() ([]byte, error) {
 	return bz, nil
@@ -58,8 +73,12 @@ func (bz HexBytes) String() string {
 func (bz HexBytes) Format(s fmt.State, verb rune) {
 	switch verb {
 	case 'p':
-		s.Write([]byte(fmt.Sprintf("%p", bz)))
+		s.Write([]byte(fmt.Sprintf("%p", bz))) //nolint:errcheck
 	default:
-		s.Write([]byte(fmt.Sprintf("%X", []byte(bz))))
+		s.Write([]byte(fmt.Sprintf("%X", []byte(bz)))) //nolint:errcheck
 	}
 }
+
+func FromBytes(b []byte) []HexBytes {
+	return []HexBytes{b}
+}
