diff --git a/rpc/client/rpc_test.go b/rpc/client/rpc_test.go
index 0b7d93d69..12efe7ed5 100644
--- a/rpc/client/rpc_test.go
+++ b/rpc/client/rpc_test.go
@@ -285,6 +285,15 @@ func TestAppCalls(t *testing.T) {
 		require.NoError(err)
 		require.Equal(block, blockByHash)
 
+		// check that the header matches the block hash
+		header, err := c.Header(context.Background(), &apph)
+		require.NoError(err)
+		require.Equal(block.Block.Header, *header.Header)
+
+		headerByHash, err := c.HeaderByHash(context.Background(), block.BlockID.Hash)
+		require.NoError(err)
+		require.Equal(header, headerByHash)
+
 		// now check the results
 		blockResults, err := c.BlockResults(context.Background(), &txh)
 		require.Nil(err, "%d: %+v", i, err)
@@ -482,12 +491,6 @@ func TestTx(t *testing.T) {
 				assert.Zero(t, ptx.Index)
 				assert.True(t, ptx.TxResult.IsOK())
 				assert.EqualValues(t, txHash, ptx.Hash)
-
-				// time to verify the proof
-				proof := ptx.Proof
-				if tc.prove && assert.EqualValues(t, tx, proof.Data) {
-					assert.NoError(t, proof.Proof.Verify(proof.RootHash, txHash))
-				}
 			}
 		}
 	}
@@ -532,6 +535,59 @@ func TestBlockSearch(t *testing.T) {
 	require.Equal(t, blockCount, 0)
 
 }
+
+func TestTxStatus(t *testing.T) {
+	c := getHTTPClient()
+	require := require.New(t)
+	mempool := node.Mempool()
+
+	// Create a new transaction
+	_, _, tx := MakeTxKV()
+
+	// Get the initial size of the mempool
+	initMempoolSize := mempool.Size()
+
+	// Add the transaction to the mempool
+	err := mempool.CheckTx(tx, nil, mempl.TxInfo{})
+	require.NoError(err)
+
+	// Check if the size of the mempool has increased
+	require.Equal(initMempoolSize+1, mempool.Size())
+
+	// Get the tx status from the mempool
+	result, err := c.TxStatus(context.Background(), types.Tx(tx).Hash())
+	require.NoError(err)
+	require.EqualValues(0, result.Height)
+	require.EqualValues(0, result.Index)
+	require.Equal("PENDING", result.Status)
+
+	// Flush the mempool
+	mempool.Flush()
+	require.Equal(0, mempool.Size())
+
+	// Get tx status after flushing it from the mempool
+	result, err = c.TxStatus(context.Background(), types.Tx(tx).Hash())
+	require.NoError(err)
+	require.EqualValues(0, result.Height)
+	require.EqualValues(0, result.Index)
+	require.Equal("UNKNOWN", result.Status)
+
+	// Broadcast the tx again
+	bres, err := c.BroadcastTxCommit(context.Background(), tx)
+	require.NoError(err)
+	require.True(bres.CheckTx.IsOK())
+	require.True(bres.DeliverTx.IsOK())
+
+	// Get the tx status
+	result, err = c.TxStatus(context.Background(), types.Tx(tx).Hash())
+	require.NoError(err)
+	require.EqualValues(bres.Height, result.Height)
+	require.EqualValues(0, result.Index)
+	require.Equal("COMMITTED", result.Status)
+	require.Equal(abci.CodeTypeOK, result.ExecutionCode)
+	require.Equal("", result.Error)
+}
+
 func TestTxSearch(t *testing.T) {
 	c := getHTTPClient()
 
@@ -567,11 +623,6 @@ func TestTxSearch(t *testing.T) {
 		assert.True(t, ptx.TxResult.IsOK())
 		assert.EqualValues(t, find.Hash, ptx.Hash)
 
-		// time to verify the proof
-		if assert.EqualValues(t, find.Tx, ptx.Proof.Data) {
-			assert.NoError(t, ptx.Proof.Proof.Verify(ptx.Proof.RootHash, find.Hash))
-		}
-
 		// query by height
 		result, err = c.TxSearch(context.Background(), fmt.Sprintf("tx.height=%d", find.Height), true, nil, nil, "asc")
 		require.Nil(t, err)
@@ -656,6 +707,30 @@ func TestTxSearch(t *testing.T) {
 	}
 }
 
+func TestDataCommitment(t *testing.T) {
+	c := getHTTPClient()
+
+	// first we broadcast a few tx
+	expectedHeight := int64(3)
+	var bres *ctypes.ResultBroadcastTxCommit
+	var err error
+	for i := int64(0); i < expectedHeight; i++ {
+		_, _, tx := MakeTxKV()
+		bres, err = c.BroadcastTxCommit(context.Background(), tx)
+		require.Nil(t, err, "%+v when submitting tx %d", err, i)
+	}
+
+	// check if height >= 3
+	actualHeight := bres.Height
+	require.LessOrEqual(t, expectedHeight, actualHeight, "couldn't create enough blocks for testing the commitment.")
+
+	// check if data commitment is not nil.
+	// Checking if the commitment is correct is done in `core/blocks_test.go`.
+	dataCommitment, err := c.DataCommitment(ctx, 1, uint64(expectedHeight))
+	require.NotNil(t, dataCommitment, "data commitment shouldn't be nul.")
+	require.Nil(t, err, "%+v when creating data commitment.", err)
+}
+
 func TestBatchedJSONRPCCalls(t *testing.T) {
 	c := getHTTPClient()
 	testBatchedJSONRPCCalls(t, c)
