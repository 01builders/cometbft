diff --git a/types/block.go b/types/block.go
index dff8d4ab5..d9d9c7058 100644
--- a/types/block.go
+++ b/types/block.go
@@ -49,9 +49,10 @@ type Block struct {
 	LastCommit *Commit      `json:"last_commit"`
 }
 
-// ValidateBasic performs basic validation that doesn't involve state data.
-// It checks the internal consistency of the block.
-// Further validation is done using state#ValidateBlock.
+// ValidateBasic performs basic validation that doesn't involve state data. It
+// checks the internal consistency of the block. Further validation is done
+// using state#ValidateBlock. celestia-app's ProcessProposal checks that the
+// block's DataHash matches the hash of the data availability header.
 func (b *Block) ValidateBasic() error {
 	if b == nil {
 		return errors.New("nil block")
@@ -79,15 +80,6 @@ func (b *Block) ValidateBasic() error {
 		)
 	}
 
-	// NOTE: b.Data.Txs may be nil, but b.Data.Hash() still works fine.
-	if !bytes.Equal(b.DataHash, b.Data.Hash()) {
-		return fmt.Errorf(
-			"wrong Header.DataHash. Expected %v, got %v",
-			b.Data.Hash(),
-			b.DataHash,
-		)
-	}
-
 	// NOTE: b.Evidence.Evidence may be nil, but we're just looping.
 	for i, ev := range b.Evidence.Evidence {
 		if err := ev.ValidateBasic(); err != nil {
@@ -105,7 +97,9 @@ func (b *Block) ValidateBasic() error {
 	return nil
 }
 
-// fillHeader fills in any remaining header fields that are a function of the block data
+// fillHeader fills in any remaining header fields that are a function of the
+// block data NOTE: we expect celestia-app to populate the block DataHash but we
+// populate it here (in celestia-core) to not break existing tests in this repo.
 func (b *Block) fillHeader() {
 	if b.LastCommitHash == nil {
 		b.LastCommitHash = b.LastCommit.Hash()
@@ -315,6 +309,27 @@ func MaxDataBytesNoEvidence(maxBytes int64, valsCount int) int64 {
 	return maxDataBytes
 }
 
+// MakeBlock returns a new block with an empty header, except what can be
+// computed from itself.
+// It populates the same set of fields validated by ValidateBasic.
+func MakeBlock(
+	height int64,
+	data Data,
+	lastCommit *Commit,
+	evidence []Evidence) *Block {
+	block := &Block{
+		Header: Header{
+			Version: cmtversion.Consensus{Block: version.BlockProtocol, App: 0},
+			Height:  height,
+		},
+		Data:       data,
+		Evidence:   EvidenceData{Evidence: evidence},
+		LastCommit: lastCommit,
+	}
+	block.fillHeader()
+	return block
+}
+
 //-----------------------------------------------------------------------------
 
 // Header defines the structure of a CometBFT block header.
@@ -770,6 +785,7 @@ func CommitToVoteSet(chainID string, commit *Commit, vals *ValidatorSet) *VoteSe
 		if commitSig.Absent() {
 			continue // OK, some precommits can be missing.
 		}
+		//nolint:gosec
 		added, err := voteSet.AddVote(commit.GetVote(int32(idx)))
 		if !added || err != nil {
 			panic(fmt.Sprintf("Failed to reconstruct LastCommit: %v", err))
@@ -866,6 +882,10 @@ func (commit *Commit) IsCommit() bool {
 // ValidateBasic performs basic validation that doesn't involve state data.
 // Does not actually check the cryptographic signatures.
 func (commit *Commit) ValidateBasic() error {
+	if commit == nil {
+		return errors.New("nil commit")
+	}
+
 	if commit.Height < 0 {
 		return errors.New("negative Height")
 	}
@@ -988,14 +1008,21 @@ func CommitFromProto(cp *cmtproto.Commit) (*Commit, error) {
 
 //-----------------------------------------------------------------------------
 
-// Data contains the set of transactions included in the block
+// Data contains all the available Data of the block.
+// Data with reserved namespaces (Txs, IntermediateStateRoots, Evidence) and
+// Celestia application specific Blobs.
 type Data struct {
-
 	// Txs that will be applied by state @ block.Height+1.
 	// NOTE: not all txs here are valid.  We're just agreeing on the order first.
 	// This means that block.AppHash does not include these txs.
 	Txs Txs `json:"txs"`
 
+	// SquareSize is the size of the square after splitting all the block data
+	// into shares. The erasure data is discarded after generation, and keeping this
+	// value avoids unnecessarily regenerating all of the shares when returning
+	// proofs that some element was included in the block
+	SquareSize uint64 `json:"square_size"`
+
 	// Volatile
 	hash cmtbytes.HexBytes
 }
@@ -1008,9 +1035,35 @@ func (data *Data) Hash() cmtbytes.HexBytes {
 	if data.hash == nil {
 		data.hash = data.Txs.Hash() // NOTE: leaves of merkle tree are TxIDs
 	}
+
+	// this is the expected behavior where `data.hash` was set by celestia-app
+	// in PrepareProposal
 	return data.hash
 }
 
+type Blob struct {
+	// NamespaceVersion is the version of the namespace. Used in conjunction
+	// with NamespaceID to determine the namespace of this blob.
+	NamespaceVersion uint8
+
+	// NamespaceID defines the namespace ID of this blob. Used in conjunction
+	// with NamespaceVersion to determine the namespace of this blob.
+	NamespaceID []byte
+
+	// Data is the actual data of the blob.
+	// (e.g. a block of a virtual sidechain).
+	Data []byte
+
+	// ShareVersion is the version of the share format that this blob should use
+	// when encoded into shares.
+	ShareVersion uint8
+}
+
+// Namespace returns the namespace of this blob encoded as a byte slice.
+func (b Blob) Namespace() []byte {
+	return append([]byte{b.NamespaceVersion}, b.NamespaceID...)
+}
+
 // StringIndented returns an indented string representation of the transactions.
 func (data *Data) StringIndented(indent string) string {
 	if data == nil {
@@ -1026,9 +1079,8 @@ func (data *Data) StringIndented(indent string) string {
 	}
 	return fmt.Sprintf(`Data{
 %s  %v
-%s}#%v`,
-		indent, strings.Join(txStrings, "\n"+indent+"  "),
-		indent, data.hash)
+}`,
+		indent, strings.Join(txStrings, "\n"+indent+"  "))
 }
 
 // ToProto converts Data to protobuf
@@ -1043,6 +1095,10 @@ func (data *Data) ToProto() cmtproto.Data {
 		tp.Txs = txBzs
 	}
 
+	tp.SquareSize = data.SquareSize
+
+	tp.Hash = data.hash
+
 	return *tp
 }
 
@@ -1064,6 +1120,9 @@ func DataFromProto(dp *cmtproto.Data) (Data, error) {
 		data.Txs = Txs{}
 	}
 
+	data.SquareSize = dp.SquareSize
+	data.hash = dp.Hash
+
 	return *data, nil
 }
 
@@ -1230,7 +1289,7 @@ func (blockID *BlockID) ToProto() cmtproto.BlockID {
 	}
 }
 
-// FromProto sets a protobuf BlockID to the given pointer.
+// BlockIDFromProto sets a protobuf BlockID to the given pointer.
 // It returns an error if the block id is invalid.
 func BlockIDFromProto(bID *cmtproto.BlockID) (*BlockID, error) {
 	if bID == nil {
