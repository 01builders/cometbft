diff --git a/store/store_test.go b/store/store_test.go
index 0e0e80832..be119dc3f 100644
--- a/store/store_test.go
+++ b/store/store_test.go
@@ -15,6 +15,7 @@ import (
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 
+	abci "github.com/tendermint/tendermint/abci/types"
 	cfg "github.com/tendermint/tendermint/config"
 	"github.com/tendermint/tendermint/crypto"
 	"github.com/tendermint/tendermint/libs/log"
@@ -22,6 +23,7 @@ import (
 	cmtstore "github.com/tendermint/tendermint/proto/tendermint/store"
 	cmtversion "github.com/tendermint/tendermint/proto/tendermint/version"
 	sm "github.com/tendermint/tendermint/state"
+	"github.com/tendermint/tendermint/test/factory"
 	"github.com/tendermint/tendermint/types"
 	cmttime "github.com/tendermint/tendermint/types/time"
 	"github.com/tendermint/tendermint/version"
@@ -45,7 +47,10 @@ func makeTestCommit(height int64, timestamp time.Time) *types.Commit {
 
 func makeBlock(height int64, state sm.State, lastCommit *types.Commit) *types.Block {
 	txs := []types.Tx{make([]byte, types.BlockPartSizeBytes)} // TX taking one block part alone
-	block, _ := state.MakeBlock(height, txs, lastCommit, nil, state.Validators.GetProposer().Address)
+	data := types.Data{
+		Txs: txs,
+	}
+	block, _ := state.MakeBlock(height, data, lastCommit, nil, state.Validators.GetProposer().Address)
 	return block
 }
 
@@ -153,7 +158,6 @@ func TestMain(m *testing.M) {
 }
 
 // TODO: This test should be simplified ...
-
 func TestBlockStoreSaveLoadBlock(t *testing.T) {
 	state, bs, cleanup := makeStateAndBlockStore(log.NewTMLogger(new(bytes.Buffer)))
 	defer cleanup()
@@ -170,13 +174,14 @@ func TestBlockStoreSaveLoadBlock(t *testing.T) {
 
 	// save a block big enough to have two block parts
 	txs := []types.Tx{make([]byte, types.BlockPartSizeBytes)} // TX taking one block part alone
-	block, _ := state.MakeBlock(bs.Height()+1, txs, new(types.Commit), nil, state.Validators.GetProposer().Address)
+	data := factory.MakeData(txs)
+	block, _ := state.MakeBlock(bs.Height()+1, data, new(types.Commit), nil, state.Validators.GetProposer().Address)
 	validPartSet := block.MakePartSet(types.BlockPartSizeBytes)
 	require.GreaterOrEqual(t, validPartSet.Total(), uint32(2))
 	part2 = validPartSet.GetPart(1)
-
 	seenCommit := makeTestCommit(block.Header.Height, cmttime.Now())
 	bs.SaveBlock(block, validPartSet, seenCommit)
+
 	require.EqualValues(t, 1, bs.Base(), "expecting the new height to be changed")
 	require.EqualValues(t, block.Header.Height, bs.Height(), "expecting the new height to be changed")
 
@@ -194,7 +199,6 @@ func TestBlockStoreSaveLoadBlock(t *testing.T) {
 	}
 
 	// End of setup, test data
-
 	commitAtH10 := makeTestCommit(10, cmttime.Now())
 	tuples := []struct {
 		block      *types.Block
@@ -367,6 +371,78 @@ func TestBlockStoreSaveLoadBlock(t *testing.T) {
 	}
 }
 
+func makeUniqueBlock(height int64, state sm.State, lastCommit *types.Commit) *types.Block {
+	data := types.Data{
+		Txs: []types.Tx{types.Tx([]byte{byte(height)})},
+	}
+	block, _ := state.MakeBlock(height, data, lastCommit, nil, state.Validators.GetProposer().Address)
+	return block
+}
+
+func TestSaveTxInfo(t *testing.T) {
+	// Create a state and a block store
+	state, blockStore, cleanup := makeStateAndBlockStore(log.NewTMLogger(new(bytes.Buffer)))
+	defer cleanup()
+
+	var allTxResponseCodes []uint32
+	var allTxLogs []string
+
+	// Create 10 blocks each with 1 tx
+	for h := int64(1); h <= 10; h++ {
+		block := makeUniqueBlock(h, state, new(types.Commit))
+		partSet := block.MakePartSet(types.BlockPartSizeBytes)
+		seenCommit := makeTestCommit(h, cmttime.Now())
+		blockStore.SaveBlock(block, partSet, seenCommit)
+
+		var txResponseCode uint32
+		var txLog string
+
+		if h%2 == 0 {
+			txResponseCode = 0
+			txLog = "success"
+		} else {
+			txResponseCode = 1
+			txLog = "failure"
+		}
+
+		// Save the tx info
+		err := blockStore.SaveTxInfo(block, []uint32{txResponseCode}, []string{txLog})
+		require.NoError(t, err)
+		allTxResponseCodes = append(allTxResponseCodes, txResponseCode)
+		allTxLogs = append(allTxLogs, txLog)
+	}
+
+	txIndex := 0
+	// Get the blocks from blockstore up to the height
+	for h := int64(1); h <= 10; h++ {
+		block := blockStore.LoadBlock(h)
+		// Check that transactions exist in the block
+		for i, tx := range block.Txs {
+			txInfo := blockStore.LoadTxInfo(tx.Hash())
+			require.Equal(t, block.Height, txInfo.Height)
+			require.Equal(t, uint32(i), txInfo.Index)
+			require.Equal(t, allTxResponseCodes[txIndex], txInfo.Code)
+			// We don't save the logs for successful transactions
+			if allTxResponseCodes[txIndex] == abci.CodeTypeOK {
+				require.Equal(t, "", txInfo.Error)
+			} else {
+				require.Equal(t, allTxLogs[txIndex], txInfo.Error)
+			}
+			txIndex++
+		}
+	}
+
+	// Get a random transaction and make sure it's indexed properly
+	block := blockStore.LoadBlock(7)
+	tx := block.Txs[0]
+	txInfo := blockStore.LoadTxInfo(tx.Hash())
+	require.Equal(t, block.Height, txInfo.Height)
+	require.Equal(t, block.Height, int64(7))
+	require.Equal(t, txInfo.Height, int64(7))
+	require.Equal(t, uint32(1), txInfo.Code)
+	require.Equal(t, "failure", txInfo.Error)
+}
+
 func TestLoadBaseMeta(t *testing.T) {
 	config := cfg.ResetTestRoot("blockchain_reactor_test")
 	defer os.RemoveAll(config.RootDir)
@@ -483,6 +559,7 @@ func TestPruneBlocks(t *testing.T) {
 	require.Nil(t, bs.LoadBlockByHash(prunedBlock.Hash()))
 	require.Nil(t, bs.LoadBlockCommit(1199))
 	require.Nil(t, bs.LoadBlockMeta(1199))
+	require.Nil(t, bs.LoadBlockMetaByHash(prunedBlock.Hash()))
 	require.Nil(t, bs.LoadBlockPart(1199, 1))
 
 	for i := int64(1); i < 1200; i++ {
@@ -520,6 +597,70 @@ func TestPruneBlocks(t *testing.T) {
 	assert.Nil(t, bs.LoadBlock(1501))
 }
 
+func TestPruneBlocksPrunesTxs(t *testing.T) {
+	config := cfg.ResetTestRoot("blockchain_reactor_test")
+	defer os.RemoveAll(config.RootDir)
+
+	stateStore := sm.NewStore(dbm.NewMemDB(), sm.StoreOptions{DiscardABCIResponses: false})
+	state, err := stateStore.LoadFromDBOrGenesisFile(config.GenesisFile())
+	require.NoError(t, err)
+
+	db := dbm.NewMemDB()
+	blockStore := NewBlockStore(db)
+	maxHeight := int64(15)
+
+	var indexedTxHashes [][]byte
+	for height := int64(1); height <= maxHeight; height++ {
+		block := makeUniqueBlock(height, state, new(types.Commit))
+		partSet := block.MakePartSet(types.BlockPartSizeBytes)
+		seenCommit := makeTestCommit(height, cmttime.Now())
+		blockStore.SaveBlock(block, partSet, seenCommit)
+		err := blockStore.SaveTxInfo(block, make([]uint32, len(block.Txs)), make([]string, len(block.Txs)))
+		require.NoError(t, err)
+		for _, tx := range block.Txs {
+			indexedTxHashes = append(indexedTxHashes, tx.Hash())
+		}
+	}
+	require.Len(t, indexedTxHashes, 15)
+
+	// Check that the saved txs exist in the block store.
+	for _, hash := range indexedTxHashes {
+		txInfo := blockStore.LoadTxInfo(hash)
+		require.NoError(t, err)
+		require.NotNil(t, txInfo, "transaction was not saved in the database")
+	}
+
+	pruned, err := blockStore.PruneBlocks(12) // prune blocks 1 to 11.
+	require.NoError(t, err)
+	assert.EqualValues(t, 11, pruned)
+
+	// Check that the transactions in the pruned blocks have been removed. We
+	// removed 11 blocks, each block has 1 tx so 11 txs should no longer
+	// exist in the db.
+	for i, hash := range indexedTxHashes {
+		txInfo := blockStore.LoadTxInfo(hash)
+		if int64(i) < 11 {
+			require.Nil(t, txInfo)
+		} else {
+			require.NotNil(t, txInfo)
+		}
+	}
+
+	// Check that transactions in remaining blocks are still there
+	for height := int64(pruned + 1); height <= maxHeight; height++ {
+		block := blockStore.LoadBlock(height)
+		for i, tx := range block.Txs {
+			hash := tx.Hash()
+			txInfo := blockStore.LoadTxInfo(hash)
+			require.NoError(t, err)
+			require.NotNil(t, txInfo)
+			require.Equal(t, height, txInfo.Height)
+			require.Equal(t, uint32(i), txInfo.Index)
+			require.Equal(t, uint32(0), txInfo.Code)
+		}
+	}
+}
+
 func TestLoadBlockMeta(t *testing.T) {
 	bs, db := freshBlockStore()
 	height := int64(10)
@@ -559,6 +700,26 @@ func TestLoadBlockMeta(t *testing.T) {
 	}
 }
 
+func TestLoadBlockMetaByHash(t *testing.T) {
+	config := cfg.ResetTestRoot("blockchain_reactor_test")
+	defer os.RemoveAll(config.RootDir)
+	stateStore := sm.NewStore(dbm.NewMemDB(), sm.StoreOptions{
+		DiscardABCIResponses: false,
+	})
+	state, err := stateStore.LoadFromDBOrGenesisFile(config.GenesisFile())
+	require.NoError(t, err)
+	bs := NewBlockStore(dbm.NewMemDB())
+
+	b1, partSet := state.MakeBlock(state.LastBlockHeight+1, types.Data{Txs: factory.MakeTxs(state.LastBlockHeight+1, 10)}, new(types.Commit), nil, state.Validators.GetProposer().Address)
+	seenCommit := makeTestCommit(1, cmttime.Now())
+	bs.SaveBlock(b1, partSet, seenCommit)
+
+	baseBlock := bs.LoadBlockMetaByHash(b1.Hash())
+	assert.EqualValues(t, b1.Header.Height, baseBlock.Header.Height)
+	assert.EqualValues(t, b1.Header.LastBlockID, baseBlock.Header.LastBlockID)
+	assert.EqualValues(t, b1.Header.ChainID, baseBlock.Header.ChainID)
+}
+
 func TestBlockFetchAtHeight(t *testing.T) {
 	state, bs, cleanup := makeStateAndBlockStore(log.NewTMLogger(new(bytes.Buffer)))
 	defer cleanup()
